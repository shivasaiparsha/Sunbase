This documentation covers how to built SUNBASE System using Spring boot framework

*************Features Of SUNBASE****************
UI/UX                       :   HTML,CSS and JAVASCRIPT used to designed the front end
User Authentication         :   Secure user login and signup with Spring Security and JWt token.
Customers API               :   Manage Customers via RESTful endpoints (/add, /get, /delete).
Authentication Required     :   Only logged-in users can access  authenticated end points
Spring Data JPA Integration :   Data storage and retrieval using JPA and a MySql database.
Customers Entity            :   Customer entity class contains all information  about the customers
Customer UniqueID           :   Generated Customer UniqueId without UUID generator

*******************UI/UX implementation Details******************
Login form: HTML page creates a simple login form where users can input their login ID and password. Upon submission,
            it currently lacks backend authentication logic, but upon clicking "Submit", it redirects the user to a hypothetical table page

 Customer Details:
                   Customer Details HTML file creates a webpage for managing a customer list. It includes a table to display customer
                   information and a form to add new customers. The page also features buttons for adding customers and synchronizing data.

Customer Add Form:
                    When user click on Add customer button Appropriate form will show on  the screen. Users can input customer details
                   such as name, address, email, and phone number, and submit them for inclusion in the list. Additionally, buttons
                   for searching and syncing data are provided for user interaction.

Search Customers:
                    Users are provided with the ability to search for customers by sorting options such as name, ID, and city, enhancing
                   their ability to manage the customer list effectively.

**********************About Spring boot******************
Spring boot is Java enterprise edition frame work.which is used to develop the microservice based applications
Microservice based applications allow developer to development easy.

Rapid Prototyping:
                 Spring Boot eliminates boilerplate code, letting you jumpstart development and focus on core functionality.
                 Simplified Configuration: Opinionated defaults and auto-configuration make setting up projects and integrating features much faster.
                  Lightweight and Standalone: Build self-contained applications easily, deployable without complex web containers or configuration

******************Spring boot Initialization*******************

 Visit Spring Initializr

create the project by providing necessary details such as Java as Language, Maven as Dependency manager, Artifact Id,GroupId, project Name
import necessary dependency into you project like Spring web, Lombok, Spring Jpa, Mysql connecter, Spring Security, jjwt APi, jjwt impl, jjwt Jackson
Unzip the downloaded file. Import the extracted project directory into your preferred IDE (e.g., IntelliJ IDEA, Eclipse).

 ********************Dependencies Features*****************
Spring Web: Enables building web applications and REST APIs with Spring's powerful features and annotations.it also provide Tomcat and Jetty servers

Lombok       :    Reduces boilerplate code by automating getters, setters, toString, and other common methods.

Spring JPA   :    Provides an abstraction layer for interacting with relational databases using JPA and Hibernate.

MySQL  Drive :    Allows your application to connect and interact with MySQL databases.

Spring Security:  Implements Spring-based security features like authentication, authorization, and access control

Jwt token :
   jjwt-api: The API module of the JSON Web Token (JWT) library, providing interfaces and abstract classes
   for working with JWTs.

   jjwt-impl: The implementation module of the JWT library, containing concrete implementations of the interfaces and classes
    defined in the API module, allowing developers to use JWT functionalities in their applications.

   jjwt-jackson: The Jackson module of the JWT library, providing support for serializing and deserializing JWTs using
   Jackson, which is a popular JSON parsing library in Java. This allows seamless integration of JWTs with Jackson-based JSON processing in applications.

******************************JWT TOKEN Implementation Details************************************************
Authentication   : When a user logs in with their credentials, the server verifies the provided information.

Token Generation : Upon successful authentication, the server generates a JWT containing user's information (payload) and signs it using a secret key.

Token Transmission: The generated JWT is then sent back to the client, usually as a response to the login request.

Token Storage     : The client typically stores the received JWT, commonly in local storage or cookies, for future use.

Subsequent Requests : For subsequent requests that require authentication, the client includes the JWT in the request header, usually as an Authorization Bearer token.

Token Verification : The server receives the request along with the JWT. It then verifies the JWT's signature using the secret key to ensure its integrity.

Payload Extraction : Upon successful verification, the server extracts the user's information from the JWT's payload.

Authorization : Based on the extracted information, the server checks whether the user is authorized to access the requested resources.

Response : If authorized, the server processes the request and sends back the appropriate response.
*******************************Internal working of Jwt Security filter**************************************************
Request Filtering:
                    Incoming requests are intercepted by a filter, often referred to as an authentication filter.
                    This filter is typically configured in the server's middleware to intercept all incoming requests
                     before they reach the actual route handlers.
JWT Extraction:
                  The filter inspects the incoming request headers for the presence of the JWT. It extracts the token from
                   the Authorization header.
Token Verification:
                    Once extracted, the filter verifies the JWT's signature using the secret key. If the signature is valid,
                    it continues processing the request; otherwise, it rejects the request with an authentication error.

Payload Extraction:
                  If the JWT's signature is valid, the filter extracts the user's information (payload) encoded within the token.

Authorization:
                 Based on the extracted user information, the filter determines whether the user is authorized to access the requested resource.
                   If authorized, it allows the request to proceed; otherwise, it denies access with an authorization error.


 Request Forwarding:
             Upon successful verification and authorization, the filter forwards the request to the appropriate route handler for further processing.

***************************Customer Controller End Points*******************************
Add Customer To Database :
                           This method adds a new customer to the database or updates an existing customer if they
                           already exist. It first checks if a customer with the provided email(unique) exists in the database.
                           If a customer is found, it updates the existing customer using the Update method. If not,
                           it generates a unique ID for the new customer using the genarateUniqueId method,
                           creates a new Customer object with the provided details, saves it to the database, and returns "successful".
Unique Id Generation:
                            a unique ID for a customer based on the provided AddCustomerDto object. It retrieves
                            a list of customers with the same ZIP code, calculates the number of customers present in
                            that ZIP code area, and constructs a unique ID by concatenating "SUNBASE", the ZIP code, and
                            the number of customers present in the ZIP code area. Finally, it returns the generated unique ID.


Get All Customers   :  The getAllCustomers() method is a controller endpoint mapped to the "/getAllCustomers" URL, accessible
                       only to users with the "admin" role. It delegates the retrieval of all customers to the userService, catches
                        any exceptions that might occur, and returns a response entity containing the list of customers
                         if successful or an empty list with a "NOT_FOUND" status if an exception occurs.

                         The getAllCustomerPresentInDb() in service class method retrieves all customers from the database using the UserRepository.
                         It returns a list of Customer objects representing the customers stored in the database.
Get ALl customers
 SortedByUsername :      The getCustomerByOrderByName() method in retrieves all customers from the database sorted by username using the UserRepository.
                         It returns a list of Customer objects representing the sorted customers.
                          we can add more filters

Get CustomerByID :     The getCustomerById method retrieves a customer from the database based on the provided email ID in
                        the GetCustomerByIdDto. It checks if a customer exists with the given email ID; if not, it throws an exception
                         indicating that the customer was not found. Otherwise, it retrieves and returns the customer
                          object associated with the provided email ID.

DeleteCustomerById :    The deleteCustomerById method removes a customer from the database based on the provided email in the DeleteByIdDto.
                        It first checks if a customer with the given email exists in the database. If not found,
                        it throws an exception indicating that the customer was not found. Otherwise, it deletes the customer
                         using the email and returns a success message indicating the deletion was successful.
All End points Covered
**********************************************SUCEESFULL**************************************************************